<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>çƒŸå°å¸‚ä¸­å¿ƒåŸåŒºå¯è§†åŒ–</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap-select/1.14.0-beta2/css/bootstrap-select.min.css"
          rel="stylesheet">
    <style>
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
        }

        #map {
            height: 100vh;
            width: 100vw;
        }

        .leaflet-control-layers,
        .leaflet-control-layers-copy {
            max-height: 300px; /* è®¾ç½®æœ€å¤§é«˜åº¦ */
            overflow-y: auto; /* è¶…å‡ºé«˜åº¦æ—¶æ˜¾ç¤ºæ»šåŠ¨æ¡ */
            min-width: 200px; /* è®¾ç½®æœ€å°å®½åº¦ */
            background: white; /* èƒŒæ™¯é¢œè‰² */
            padding: 10px; /* å†…è¾¹è· */
            border: 1px solid #ccc; /* è¾¹æ¡† */
            box-sizing: border-box; /* åŒ…å« padding å’Œ border */
        }

        /* é˜²æ­¢æ§ä»¶å†…å®¹æº¢å‡º */
        .leaflet-control-layers label,
        .leaflet-control-layers-copy label {
            word-wrap: break-word; /* é•¿æ–‡æœ¬è‡ªåŠ¨æ¢è¡Œ */
            white-space: normal; /* å…è®¸æ¢è¡Œ */
            margin-bottom: 5px; /* å¢åŠ é—´è· */
        }

        /* è°ƒæ•´æ»šåŠ¨æ¡çš„æ ·å¼ */
        .leaflet-control-layers::-webkit-scrollbar,
        .leaflet-control-layers-copy::-webkit-scrollbar {
            width: 8px;
        }

        .leaflet-control-layers::-webkit-scrollbar-thumb,
        .leaflet-control-layers-copy::-webkit-scrollbar-thumb {
            background: #ccc;
            border-radius: 4px;
        }

        .leaflet-control-layers::-webkit-scrollbar-track,
        .leaflet-control-layers-copy::-webkit-scrollbar-track {
            background: #f1f1f1;
        }

        .leaflet-control-buttons {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .leaflet-control-buttons button {
            padding: 5px;
            cursor: pointer;
            background: white;
            border: 1px solid #ccc;
        }

        .leaflet-control-zoom-to-all {
            padding: 5px;
            cursor: pointer;
            background: white;
            border: 1px solid #ccc;
        }

        .leaflet-legend {
            background: white;
            padding: 10px;
            border: 1px solid #ccc;
        }

        .leaflet-legend .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }

        .leaflet-legend .legend-color {
            width: 20px;
            height: 20px;
            margin-right: 5px;
        }

        .leaflet-bottom.leaflet-left {
            display: flex;
            gap: 10px;
        }

        #extraFolderForm {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1000;
            background: white;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            max-width: 300px;
            width: 100%;
        }

        .filter-level {
            margin-bottom: 10px;
        }

        .filter-buttons {
            display: flex;
            gap: 5px;
            margin-bottom: 5px;
        }

        .filter-buttons button {
            flex: 1;
            padding: 3px;
            font-size: 12px;
        }

        .selectpicker {
            width: 100%;
        }

        /* æ·»åŠ åŠ è½½æŒ‡ç¤ºå™¨æ ·å¼ */
        #loading-indicator {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.9);
            padding: 20px;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
            z-index: 2000;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* æ·»åŠ æ§ä»¶æŠ˜å å’Œå±•å¼€çš„æ ·å¼ - æ›´ç²¾ç¡®çš„é«˜åº¦æ§åˆ¶ */
        #currentLayerControl.control-collapsed {
            width: auto !important;
            min-width: unset !important;
            padding: 5px !important;
            height: auto !important;
            max-height: 40px !important; /* åªä¿ç•™æ ‡é¢˜æ é«˜åº¦ */
            overflow: hidden !important;
        }

        #planLayerControl.control-collapsed {
            width: auto !important;
            min-width: unset !important;
            padding: 5px !important;
            height: auto !important;
            max-height: 40px !important;
            overflow: hidden !important;
        }

        #extraLayerControl.control-collapsed {
            width: auto !important;
            min-width: unset !important;
            padding: 5px !important;
            height: auto !important;
            max-height: 40px !important;
            overflow: hidden !important;
        }

        /* ç¡®ä¿å±•å¼€çŠ¶æ€ä¸‹çš„é«˜åº¦æ­£ç¡® */
        #currentLayerControl.control-expanded {
            width: 300px !important;
            min-width: 300px !important;
            padding: 10px !important;
            max-height: 300px !important;
            overflow-y: auto !important;
        }

        #planLayerControl.control-expanded {
            width: 300px !important;
            min-width: 300px !important;
            padding: 10px !important;
            max-height: 300px !important;
            overflow-y: auto !important;
        }

        #extraLayerControl.control-expanded {
            width: 600px !important;
            min-width: 600px !important;
            padding: 10px !important;
            max-height: 300px !important;
            overflow-y: auto !important;
        }

        /* ç¡®ä¿å›¾å±‚åç§°æ­£ç¡®æ˜¾ç¤º */
        .leaflet-control-layers-overlays label {
            display: block !important;
            margin-left: 0 !important;
            white-space: nowrap !important;
            overflow: hidden !important;
            text-overflow: ellipsis !important;
            white-space: normal !important;
            word-break: break-word !important;
            max-width: 580px !important;
        }

        /* ç¡®ä¿æ§ä»¶åœ¨æŠ˜å çŠ¶æ€ä¸‹ä¿æŒåœ¨æ­£ç¡®ä½ç½® */
        .leaflet-bottom .leaflet-control {
            margin-bottom: 10px !important;
            vertical-align: bottom !important;
        }

        /* æ§ä»¶æŠ˜å çŠ¶æ€ä¸‹çš„ä½ç½®è°ƒæ•´ */
        #currentLayerControl.control-collapsed,
        #planLayerControl.control-collapsed,
        #extraLayerControl.control-collapsed {
            position: relative !important;
            bottom: 0 !important;
            margin-bottom: 10px !important;
            align-self: flex-end !important;
        }

        /* ç¡®ä¿æ§ä»¶å®¹å™¨æ­£ç¡®å¯¹é½ */
        .leaflet-bottom .leaflet-left {
            display: flex !important;
            flex-direction: column !important;
            align-items: flex-start !important;
            justify-content: flex-end !important;
            height: auto !important;
        }

        /* æ·»åŠ å¯¹extraControlå®¹å™¨çš„ç‰¹å®šé€‰æ‹©å™¨ */
        .leaflet-control-layers-copy.control-collapsed,
        #extraLayerControl.control-collapsed {
            width: auto !important;
            min-width: unset !important;
            max-width: fit-content !important;
            padding: 5px !important;
            height: auto !important;
            max-height: 40px !important;
            overflow: hidden !important;
        }

        .leaflet-control-layers-copy.control-expanded,
        #extraLayerControl.control-expanded {
            width: 600px !important;
            min-width: 600px !important;
            padding: 10px !important;
            max-height: 300px !important;
            overflow-y: auto !important;
        }

        /* è‡ªå®šä¹‰tooltipæ ·å¼ */
        .custom-tooltip {
            background-color: white;
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 5px;
            font-size: 12px;
            max-width: 300px;
            box-shadow: 0 1px 5px rgba(0,0,0,0.4);
        }

        .custom-tooltip table {
            margin: 0;
            padding: 0;
            width: 100%;
        }

        /* å›¾å±‚åç§°tooltipæ ·å¼ */
        .layer-name-tooltip {
            background-color: rgba(255, 255, 255, 0.9);
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 5px 8px;
            font-size: 12px;
            font-weight: bold;
            box-shadow: 0 1px 5px rgba(0,0,0,0.2);
        }
    </style>
</head>
<body>
<!-- Extra æ–‡ä»¶å¤¹ç­›é€‰è¡¨å• -->


<!-- åœ¨ç­›é€‰è¡¨å•çš„æœ€åæ·»åŠ æŒ‰é’® -->
<form id="extraFolderForm">
    <!-- å…¶ä»–ç­›é€‰å­—æ®µ -->
    <div class="filter-level">
        <label for="first_level">æ—¶é—´:</label>
        <div class="filter-buttons">
            <button type="button" class="btn btn-sm btn-secondary" onclick="selectAll('first_level')">é€‰æ‹©å…¨éƒ¨</button>
            <button type="button" class="btn btn-sm btn-secondary" onclick="deselectAll('first_level')">å–æ¶ˆå…¨éƒ¨</button>
        </div>
        <select id="first_level" class="selectpicker" multiple data-live-search="true" title="æ—¶é—´"></select>
    </div>
    <div class="filter-level">
        <label for="second_level">ç±»å‹:</label>
        <div class="filter-buttons">
            <button type="button" class="btn btn-sm btn-secondary" onclick="selectAll('second_level')">é€‰æ‹©å…¨éƒ¨</button>
            <button type="button" class="btn btn-sm btn-secondary" onclick="deselectAll('second_level')">å–æ¶ˆå…¨éƒ¨</button>
        </div>
        <select id="second_level" class="selectpicker" multiple data-live-search="true" title="ç±»å‹"></select>
    </div>
    <div class="filter-level">
        <label for="third_level">çŠ¶æ€:</label>
        <div class="filter-buttons">
            <button type="button" class="btn btn-sm btn-secondary" onclick="selectAll('third_level')">é€‰æ‹©å…¨éƒ¨</button>
            <button type="button" class="btn btn-sm btn-secondary" onclick="deselectAll('third_level')">å–æ¶ˆå…¨éƒ¨</button>
        </div>
        <select id="third_level" class="selectpicker" multiple data-live-search="true" title="çŠ¶æ€"></select>
    </div>
    <button type="button" class="btn btn-primary mt-2" onclick="filterExtraFolders()">ç­›é€‰</button>
</form>


<div id="map"></div>

<!-- è§†å›¾ç®¡ç†æ§ä»¶ - æ”¾åœ¨å·¦ä¾§æ›´ä½çš„ä½ç½® -->
<div style="position: absolute; top: 250px; left: 10px; z-index: 1000; background-color: white; padding: 5px; border-radius: 4px; box-shadow: 0 1px 5px rgba(0,0,0,0.4);">
    <div style="text-align: center; font-weight: bold; margin-bottom: 5px; font-size: 12px;">è§†å›¾ç®¡ç†</div>
    <button onclick="saveViewDirectly()" style="display: block; width: 100%; margin-bottom: 5px; padding: 4px; background-color: #4CAF50; color: white; border: none; border-radius: 3px; cursor: pointer; font-size: 12px;">
        ğŸ’¾ ä¿å­˜è§†å›¾
    </button>
    <button onclick="document.getElementById('directFileInput').click()" style="display: block; width: 100%; padding: 4px; background-color: #2196F3; color: white; border: none; border-radius: 3px; cursor: pointer; font-size: 12px;">
        ğŸ“‚ åŠ è½½è§†å›¾
    </button>
    <input type="file" id="directFileInput" style="display: none;" accept=".json" onchange="loadViewDirectly(this.files[0])">
</div>

<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha3/dist/js/bootstrap.bundle.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap-select/1.14.0-beta2/js/bootstrap-select.min.js"></script>
<script>
    const layerColors = [
        "#FF0000", "#00FF00", "#0000FF", "#FF00FF", "#FFFF00",
        "#00FFFF", "#FFA500", "#800080", "#008000", "#000080",
        "#FF4500", "#ADFF2F", "#00CED1", "#8A2BE2", "#FF1493",
        "#32CD32", "#6A5ACD", "#FF69B4", "#20B2AA", "#7B68EE",
        
        "#8B4513",  // é©¬éæ£•è‰²
        "#4169E1",  // çš‡å®¶è“
        "#9ACD32",  // é»„ç»¿è‰²
        "#FF6347",  // ç•ªèŒ„çº¢
        "#BA55D3",  // ä¸­ç­‰å…°èŠ±ç´«
        "#2E8B57",  // æµ·æ´‹ç»¿
        "#DAA520",  // é‡‘èŠé»„
        "#800000",  // æ —è‰²
        "#E6E6FA",  // æ·¡ç´«è‰²
        "#FFA07A",  // æµ…é²‘é±¼è‰²
        "#3CB371",  // ä¸­æµ·æ´‹ç»¿
        "#F4A460",  // æ²™è¤è‰²
        "#9370DB",  // ä¸­ç´«è‰²
        "#48D1CC",  // ä¸­ç»¿å®çŸ³
        "#CD853F",  // ç§˜é²è‰²
        "#DB7093"   // è‹ç´«ç½—å…°çº¢
    ];

    // åŠ¨æ€è°ƒæ•´æ§ä»¶å®½åº¦
    window.addEventListener('load', () => {
        // è°ƒæ•´ layerControl çš„å®½åº¦
        const layerControlContainer = document.querySelector('.leaflet-control-layers');
        if (layerControlContainer) {
            const contentWidth = layerControlContainer.scrollWidth;
            const minWidth = 300; // è®¾ç½®æœ€å°å®½åº¦
            const maxWidth = 500; // è®¾ç½®æœ€å¤§å®½åº¦
            layerControlContainer.style.width = `${Math.min(Math.max(contentWidth, minWidth), maxWidth)}px`;
        }

        // è°ƒæ•´ä¸­é—´æ§ä»¶çš„å®½åº¦
        const layerControlCopyContainer = document.querySelector('.leaflet-control-layers-copy');
        if (layerControlCopyContainer) {
            const contentWidth = layerControlCopyContainer.scrollWidth;
            const minWidth = 400; // ä¿®æ”¹æœ€å°å®½åº¦ä¸º400
            const maxWidth = 500; // ä¿®æ”¹æœ€å¤§å®½åº¦ä¸º400
            layerControlCopyContainer.style.width = `${Math.min(Math.max(contentWidth, minWidth), maxWidth)}px`;
        }

        // è°ƒæ•´æ–°å¢æ§ä»¶çš„å®½åº¦
        const extraLayerControl = document.getElementById('extraLayerControl');
        if (extraLayerControl) {
            const contentWidth = extraLayerControl.scrollWidth;
            const minWidth = 600; // è®¾ç½®æœ€å°å®½åº¦
            const maxWidth = 600; // è®¾ç½®æœ€å¤§å®½åº¦
            extraLayerControl.style.width = `${Math.min(Math.max(contentWidth, minWidth), maxWidth)}px`;
        }
    });



    function getLayerColor(layerName) {
        let hash = 0;
        for (let i = 0; i < layerName.length; i++) {
            hash = (hash << 5) - hash + layerName.charCodeAt(i);
            hash |= 0;
        }
        return layerColors[Math.abs(hash) % layerColors.length];
    }

    // ä½¿ç”¨é«˜å¾·åœ°å›¾æœåŠ¡ - ç§»åŠ¨å›¾å±‚æ§åˆ¶å™¨ä½ç½®
    const map = L.map('map').setView([37.4638, 121.4479], 13);

    // åŸºç¡€å›¾å±‚ç»„
    const baseMaps = {};

    // é«˜å¾·åœ°å›¾çŸ¢é‡å›¾å±‚
    const gaodeNormal = L.tileLayer('https://webrd0{s}.is.autonavi.com/appmaptile?lang=zh_cn&size=1&scale=1&style=8&x={x}&y={y}&z={z}', {
        subdomains: ['1', '2', '3', '4'],
        attribution: '&copy; é«˜å¾·åœ°å›¾'
    });
    baseMaps["é«˜å¾·æ ‡å‡†åœ°å›¾"] = gaodeNormal;

    // é«˜å¾·å«æ˜Ÿå½±åƒå›¾å±‚
    const gaodeSatellite = L.tileLayer('https://webst0{s}.is.autonavi.com/appmaptile?style=6&x={x}&y={y}&z={z}', {
        subdomains: ['1', '2', '3', '4'],
        attribution: '&copy; é«˜å¾·åœ°å›¾'
    });
    baseMaps["é«˜å¾·å«æ˜Ÿå½±åƒ"] = gaodeSatellite;

    // é«˜å¾·å½±åƒæ³¨è®°å›¾å±‚
    const gaodeLabels = L.tileLayer('https://webst0{s}.is.autonavi.com/appmaptile?style=8&x={x}&y={y}&z={z}', {
        subdomains: ['1', '2', '3', '4'],
        attribution: '&copy; é«˜å¾·åœ°å›¾'
    });
    baseMaps["é«˜å¾·å½±åƒ+è·¯ç½‘"] = L.layerGroup([gaodeSatellite, gaodeLabels]);

    // æ·»åŠ é»˜è®¤å›¾å±‚
    gaodeNormal.addTo(map);

    // æ·»åŠ å›¾å±‚æ§åˆ¶å™¨åˆ°åœ°å›¾å·¦ä¸Šè§’ï¼Œé¿å…ä¸å³ä¸Šè§’æ§ä»¶é‡å 
    L.control.layers(baseMaps, null, {position: 'topleft'}).addTo(map);

    const layerGroup = L.layerGroup().addTo(map);
    
    const extraControl = L.control.layers(null, null, {collapsed: false, position: 'bottomleft'}).addTo(map);
    // ä¿®æ”¹layerControlçš„åˆ›å»ºæ–¹å¼
    const layerControl = L.control.layers(null, null, {
        position: 'bottomleft',
        collapsed: false
    });

    // ä¿å­˜åŸå§‹çš„onAddæ–¹æ³•
    const originalOnAdd = L.Control.Layers.prototype.onAdd;

    // ä¸ºæ‰€æœ‰ä¸‰ä¸ªæ§ä»¶æ·»åŠ é€šç”¨çš„æŠ˜å /å±•å¼€å¤„ç†å‡½æ•°
    function setupCollapseButton(collapseBtn, container, containerType) {
        collapseBtn.onclick = function(e) {
            // é˜»æ­¢äº‹ä»¶å†’æ³¡ï¼Œé¿å…è§¦å‘åœ°å›¾ç‚¹å‡»äº‹ä»¶
            L.DomEvent.stopPropagation(e);
            L.DomEvent.preventDefault(e);
            
            // æ ¹æ®æ§ä»¶ç±»å‹è·å–æ­£ç¡®çš„å®¹å™¨
            let currentContainer;
            if (containerType === 'current') {
                currentContainer = document.getElementById('currentLayerControl');
            } else if (containerType === 'plan') {
                currentContainer = document.getElementById('planLayerControl');
            } else if (containerType === 'extra') {
                currentContainer = document.getElementById('extraLayerControl');
            }
            
            if (!currentContainer) {
                console.error('æ‰¾ä¸åˆ°æ§ä»¶å®¹å™¨:', containerType);
                return;
            }
            
            if (currentContainer.classList.contains('control-collapsed')) {
                // å±•å¼€
                currentContainer.classList.remove('control-collapsed');
                currentContainer.classList.add('control-expanded');
                this.innerHTML = 'âˆ’';
            } else {
                // æŠ˜å 
                currentContainer.classList.remove('control-expanded');
                currentContainer.classList.add('control-collapsed');
                this.innerHTML = '+';
            }
        };
    }

    // ä¿®æ”¹layerControlçš„onAddæ–¹æ³•
    layerControl.onAdd = function (map) {
        // è°ƒç”¨åŸå§‹çš„onAddæ–¹æ³•è·å–æ§ä»¶å®¹å™¨
        const container = originalOnAdd.call(this, map);
        
        // æ·»åŠ å”¯ä¸€ID
        container.id = 'currentLayerControl';
        
        // åˆ›å»ºæ ‡é¢˜æ ï¼ŒåŒ…å«æ ‡é¢˜å’ŒæŠ˜å æŒ‰é’®
        const headerDiv = document.createElement('div');
        headerDiv.style.display = 'flex';
        headerDiv.style.justifyContent = 'space-between';
        headerDiv.style.alignItems = 'center';
        headerDiv.style.marginBottom = '5px';
        
        // æ·»åŠ æ ‡é¢˜
        const titleDiv = document.createElement('div');
        titleDiv.innerHTML = '<strong>ç°çŠ¶å›¾å±‚</strong>';
        headerDiv.appendChild(titleDiv);
        
        // æ·»åŠ æŠ˜å æŒ‰é’®
        const collapseBtn = document.createElement('button');
        collapseBtn.innerHTML = 'âˆ’';  // ä½¿ç”¨å‡å·è¡¨ç¤ºæŠ˜å 
        collapseBtn.style.width = '24px';
        collapseBtn.style.height = '24px';
        collapseBtn.style.border = '1px solid #ccc';
        collapseBtn.style.borderRadius = '3px';
        collapseBtn.style.background = 'white';
        collapseBtn.style.cursor = 'pointer';
        collapseBtn.title = 'æŠ˜å /å±•å¼€';
        
        // è®¾ç½®æŠ˜å /å±•å¼€åŠŸèƒ½
        setupCollapseButton(collapseBtn, container, 'current');
        
        headerDiv.appendChild(collapseBtn);
        
        // è·å–å†…å®¹åŒºåŸŸ
        const contentDiv = container.querySelector('.leaflet-control-layers-list');
        const buttonsDiv = document.createElement('div');
        buttonsDiv.className = 'leaflet-control-buttons';
        buttonsDiv.innerHTML = `
            <button style="float: left;">å…¨éƒ¨æ‰“å¼€</button>
            <button style="float: right;">å…¨éƒ¨å…³é—­</button>
        `;
        
        // æ’å…¥æ ‡é¢˜æ å’ŒæŒ‰é’®åŒºåŸŸ
        container.insertBefore(headerDiv, container.firstChild);
        container.insertBefore(buttonsDiv, contentDiv);
        
        // æ·»åŠ æŒ‰é’®äº‹ä»¶å¤„ç†
        buttonsDiv.querySelector('button:nth-child(1)').onclick = () => {
            Object.values(currentLayers).forEach(layer => map.addLayer(layer));
            updateLegend({...currentLayers, ...planLayers, ...extraLayers});
        };
        
        buttonsDiv.querySelector('button:nth-child(2)').onclick = () => {
            Object.values(currentLayers).forEach(layer => map.removeLayer(layer));
            updateLegend({...currentLayers, ...planLayers, ...extraLayers});
        };
        
        // åˆå§‹è®¾ç½®ä¸ºå±•å¼€çŠ¶æ€
        container.classList.add('control-expanded');
        
        return container;
    };

    // ä¿®æ”¹layerControlCopyçš„onAddæ–¹æ³•
    const layerControlCopy = L.control.layers(null, null, {
        position: 'bottomleft',
        collapsed: false
    });

    // ä¿®æ”¹layerControlCopyçš„onAddæ–¹æ³•
    layerControlCopy.onAdd = function (map) {
        // è°ƒç”¨åŸå§‹çš„onAddæ–¹æ³•è·å–æ§ä»¶å®¹å™¨
        const container = originalOnAdd.call(this, map);
        
        // æ·»åŠ å”¯ä¸€ID
        container.id = 'planLayerControl';
        
        // åˆ›å»ºæ ‡é¢˜æ ï¼ŒåŒ…å«æ ‡é¢˜å’ŒæŠ˜å æŒ‰é’®
        const headerDiv = document.createElement('div');
        headerDiv.style.display = 'flex';
        headerDiv.style.justifyContent = 'space-between';
        headerDiv.style.alignItems = 'center';
        headerDiv.style.marginBottom = '5px';
        
        // æ·»åŠ æ ‡é¢˜
        const titleDiv = document.createElement('div');
        titleDiv.innerHTML = '<strong>è§„åˆ’å›¾å±‚</strong>';
        headerDiv.appendChild(titleDiv);
        
        // æ·»åŠ æŠ˜å æŒ‰é’®
        const collapseBtn = document.createElement('button');
        collapseBtn.innerHTML = 'âˆ’';  // ä½¿ç”¨å‡å·è¡¨ç¤ºæŠ˜å 
        collapseBtn.style.width = '24px';
        collapseBtn.style.height = '24px';
        collapseBtn.style.border = '1px solid #ccc';
        collapseBtn.style.borderRadius = '3px';
        collapseBtn.style.background = 'white';
        collapseBtn.style.cursor = 'pointer';
        collapseBtn.title = 'æŠ˜å /å±•å¼€';
        
        // è®¾ç½®æŠ˜å /å±•å¼€åŠŸèƒ½
        setupCollapseButton(collapseBtn, container, 'plan');
        
        headerDiv.appendChild(collapseBtn);
        
        // è·å–å†…å®¹åŒºåŸŸ
        const contentDiv = container.querySelector('.leaflet-control-layers-list');
        const buttonsDiv = document.createElement('div');
        buttonsDiv.className = 'leaflet-control-buttons';
        buttonsDiv.innerHTML = `
            <button style="float: left;">å…¨éƒ¨æ‰“å¼€</button>
            <button style="float: right;">å…¨éƒ¨å…³é—­</button>
        `;
        
        // æ’å…¥æ ‡é¢˜æ å’ŒæŒ‰é’®åŒºåŸŸ
        container.insertBefore(headerDiv, container.firstChild);
        container.insertBefore(buttonsDiv, contentDiv);
        
        // æ·»åŠ æŒ‰é’®äº‹ä»¶å¤„ç†
        buttonsDiv.querySelector('button:nth-child(1)').onclick = () => {
            Object.values(planLayers).forEach(layer => map.addLayer(layer));
            updateLegend({...currentLayers, ...planLayers, ...extraLayers});
        };
        
        buttonsDiv.querySelector('button:nth-child(2)').onclick = () => {
            Object.values(planLayers).forEach(layer => map.removeLayer(layer));
            updateLegend({...currentLayers, ...planLayers, ...extraLayers});
        };
        
        // åˆå§‹è®¾ç½®ä¸ºå±•å¼€çŠ¶æ€
        container.classList.add('control-expanded');
        
        return container;
    };

    // æ·»åŠ åˆ°åœ°å›¾
    layerControl.addTo(map);
    layerControlCopy.addTo(map);

    // æ¢å¤åŸå§‹çš„å›¾ä¾‹åˆ›å»ºé€»è¾‘ï¼Œä½†ä¼˜åŒ–å†…å­˜ä½¿ç”¨
    function updateLegend(layers) {
        // è·å–æˆ–åˆ›å»ºå›¾ä¾‹å®¹å™¨
        let legendContainer = document.getElementById('legend-container');
        if (!legendContainer) {
            legendContainer = document.createElement('div');
            legendContainer.id = 'legend-container';
            legendContainer.className = 'leaflet-legend';
            legendContainer.style.maxHeight = '300px';
            legendContainer.style.overflowY = 'auto';
            
            // åˆ›å»ºæ ‡é¢˜
            const titleDiv = document.createElement('div');
            titleDiv.innerHTML = '<strong>å›¾ä¾‹</strong>';
            legendContainer.appendChild(titleDiv);
            
            // åˆ›å»ºå†…å®¹åŒºåŸŸ
            const contentDiv = document.createElement('div');
            contentDiv.id = 'legend-content';
            legendContainer.appendChild(contentDiv);
            
            // æ·»åŠ åˆ°åœ°å›¾
            legend.onAdd = function() {
                return legendContainer;
            };
            legend.addTo(map);
        }
        
        // å†…å­˜ä¼˜åŒ–ï¼šé™åˆ¶å›¾ä¾‹ä¸­æ˜¾ç¤ºçš„å›¾å±‚æ•°é‡
        const maxLegendItems = 40;
        const visibleLayers = {};
        let count = 0;
        
        // åªæ·»åŠ å½“å‰å¯è§çš„å›¾å±‚åˆ°å›¾ä¾‹
        Object.entries(layers).forEach(([name, layer]) => {
            if (map.hasLayer(layer) && count < maxLegendItems) {
                visibleLayers[name] = layer;
                count++;
            }
        });
        
        // æ›´æ–°å›¾ä¾‹å†…å®¹
        const legendContent = document.getElementById('legend-content');
        if (legendContent) {
            legendContent.innerHTML = '';
            
            if (count >= maxLegendItems) {
                const notice = document.createElement('div');
                notice.textContent = `æ˜¾ç¤ºå‰ ${maxLegendItems} ä¸ªå›¾å±‚ (æ€»å…± ${Object.keys(layers).filter(name => map.hasLayer(layers[name])).length} ä¸ª)`;
                notice.style.fontStyle = 'italic';
                notice.style.marginBottom = '5px';
                legendContent.appendChild(notice);
            }
            
            Object.entries(visibleLayers).forEach(([name, layer]) => {
            if (map.hasLayer(layer)) {
                    const item = document.createElement('div');
                    item.className = 'legend-item';
                    
                    const color = document.createElement('div');
                    color.className = 'legend-color';
                    color.style.backgroundColor = getLayerColor(name);
                    
                    const label = document.createElement('div');
                    label.textContent = name;
                    
                    item.appendChild(color);
                    item.appendChild(label);
                    legendContent.appendChild(item);
                }
            });
        }
    }


    function getAllVisibleLayersBounds() {
        // å®šä¹‰çƒŸå°å¸‚çš„é»˜è®¤è§†å›¾èŒƒå›´
        const defaultBounds = L.latLngBounds(
            L.latLng(37.3638, 121.2479), // è¥¿å—è§’
            L.latLng(37.5638, 121.6479)  // ä¸œåŒ—è§’
        );

        // åˆ›å»ºä¸€ä¸ªæ–°çš„è¾¹ç•Œå¯¹è±¡
        let bounds = null;
        let hasVisibleLayers = false;
        
        console.log("å¼€å§‹è®¡ç®—æ‰€æœ‰å¯è§å›¾å±‚çš„è¾¹ç•Œ");
        
        // ç›´æ¥å¤„ç†æˆ‘ä»¬çŸ¥é“çš„å›¾å±‚å¯¹è±¡
        const allLayerObjects = [
            ...Object.entries(currentLayers),
            ...Object.entries(planLayers),
            ...Object.entries(extraLayers)
        ];
        
        console.log(`æ‰¾åˆ° ${allLayerObjects.length} ä¸ªå›¾å±‚å¯¹è±¡`);
        
        // éå†å¹¶å¤„ç†æ¯ä¸ªå›¾å±‚
        for (const [name, layer] of allLayerObjects) {
            if (!map.hasLayer(layer)) {
                console.log(`å›¾å±‚ ${name} ä¸å¯è§ï¼Œè·³è¿‡`);
                continue;
            }
            
            console.log(`å¤„ç†å¯è§å›¾å±‚: ${name}`);
            
            try {
                if (layer instanceof L.FeatureGroup || layer instanceof L.LayerGroup) {
                    console.log(`${name} æ˜¯å›¾å±‚ç»„ï¼Œå¤„ç†å­å›¾å±‚`);
                    const subLayers = layer.getLayers();
                    
                    for (const subLayer of subLayers) {
                        // æ£€æŸ¥å­å›¾å±‚æ˜¯å¦æœ‰getBoundsæ–¹æ³•
                        if (subLayer.getBounds && typeof subLayer.getBounds === 'function') {
                            const subBounds = subLayer.getBounds();
                            if (subBounds && subBounds.isValid()) {
                                console.log(`æ·»åŠ å­å›¾å±‚è¾¹ç•Œ: ${subBounds.toBBoxString()}`);
                                if (bounds === null) {
                                    bounds = L.latLngBounds(subBounds);
                                } else {
                                    bounds.extend(subBounds);
                                }
                                hasVisibleLayers = true;
                            }
                        } 
                        // æ£€æŸ¥å›¾å±‚æ˜¯å¦æœ‰getBoundsæ–¹æ³•
                        else if (layer.getBounds && typeof layer.getBounds === 'function') {
                            const layerBounds = layer.getBounds();
                            if (layerBounds && layerBounds.isValid()) {
                                console.log(`æ·»åŠ å›¾å±‚è¾¹ç•Œ ${name}: ${layerBounds.toBBoxString()}`);
                                if (bounds === null) {
                                    bounds = L.latLngBounds(layerBounds);
                                } else {
                                    bounds.extend(layerBounds);
                                }
                                hasVisibleLayers = true;
                            } else {
                                console.log(`å›¾å±‚ ${name} çš„è¾¹ç•Œæ— æ•ˆ`);
                            }
                        } else {
                            console.log(`å›¾å±‚ ${name} æ²¡æœ‰getBoundsæ–¹æ³•`);
                        }
                    }
                } 
                // æ£€æŸ¥å›¾å±‚æ˜¯å¦æœ‰getBoundsæ–¹æ³•
                else if (layer.getBounds && typeof layer.getBounds === 'function') {
                    const layerBounds = layer.getBounds();
                    if (layerBounds && layerBounds.isValid()) {
                        console.log(`æ·»åŠ å›¾å±‚è¾¹ç•Œ ${name}: ${layerBounds.toBBoxString()}`);
                        if (bounds === null) {
                            bounds = L.latLngBounds(layerBounds);
                        } else {
                            bounds.extend(layerBounds);
                        }
                        hasVisibleLayers = true;
                    } else {
                        console.log(`å›¾å±‚ ${name} çš„è¾¹ç•Œæ— æ•ˆ`);
                    }
                } else {
                    console.log(`å›¾å±‚ ${name} æ²¡æœ‰getBoundsæ–¹æ³•`);
                }
            } catch (e) {
                console.error(`å¤„ç†å›¾å±‚ ${name} æ—¶å‡ºé”™:`, e);
            }
        }
        
        // å¦‚æœæ²¡æœ‰æœ‰æ•ˆè¾¹ç•Œï¼Œè¿”å›é»˜è®¤å€¼
        if (!hasVisibleLayers || !bounds || !bounds.isValid()) {
            console.log("æ²¡æœ‰æ‰¾åˆ°æœ‰æ•ˆçš„å›¾å±‚è¾¹ç•Œï¼Œä½¿ç”¨é»˜è®¤èŒƒå›´");
            return defaultBounds;
        }
        
        console.log(`æœ€ç»ˆè®¡ç®—çš„è¾¹ç•Œ: ${bounds.toBBoxString()}`);
        return bounds;
    }

    const zoomToAllControl = L.control({ position: 'topleft' });
    zoomToAllControl.onAdd = function (map) {
        const div = L.DomUtil.create('div', 'leaflet-control-zoom-to-all');
        div.innerHTML = `<button>å…¨å›¾</button>`;
        div.querySelector('button').onclick = function() {
            console.log("ç‚¹å‡»äº†å…¨å›¾æŒ‰é’®");
            try {
            const bounds = getAllVisibleLayersBounds();
                console.log(`è·å–åˆ°çš„è¾¹ç•Œ: ${bounds.toBBoxString()}`);
                
                // ä½¿ç”¨é€‚å½“çš„paddingå’Œæœ€å¤§ç¼©æ”¾çº§åˆ«
                map.fitBounds(bounds, {
                    padding: [50, 50],
                    maxZoom: 15,
                    animate: true
                });
                
                console.log("å®Œæˆç¼©æ”¾æ“ä½œ");
            } catch (e) {
                console.error('ç¼©æ”¾åˆ°å…¨å›¾æ—¶å‡ºé”™:', e);
                // å‡ºé”™æ—¶å›åˆ°é»˜è®¤è§†å›¾
                map.setView([37.4638, 121.4479], 13);
            }
        };
        return div;
    };
    zoomToAllControl.addTo(map);

    const legend = L.control({position: 'bottomright'});
    legend.onAdd = function (map) {
        const div = L.DomUtil.create('div', 'leaflet-legend leaflet-control');
        div.style.backgroundColor = 'white';
        div.style.padding = '6px 8px';
        div.style.border = '2px solid rgba(0,0,0,0.2)';
        div.style.borderRadius = '4px';
        div.style.boxShadow = 'none';
        div.style.maxHeight = '300px'; // è®¾ç½®æœ€å¤§é«˜åº¦
        div.style.overflowY = 'auto';  // æ·»åŠ å‚ç›´æ»šåŠ¨æ¡
        div.style.overflowX = 'hidden'; // éšè—æ°´å¹³æ»šåŠ¨æ¡
        div.innerHTML = '<strong>å›¾ä¾‹</strong>';
        return div;
    };
    legend.addTo(map);

    let currentLayers = {};
    let planLayers = {};
    let extraLayers = {};

    // åŠ è½½ Extra æ–‡ä»¶å¤¹åˆ—è¡¨
    function loadExtraFolders() {
        fetch('/extra-folders')
                .then(response => response.json())
                .then(folders => {
                    const extraFolderSelect = document.getElementById('extra_folder');
                    folders.forEach(folder => {
                        const option = document.createElement('option');
                        option.value = folder;
                        option.textContent = folder;
                        extraFolderSelect.appendChild(option);
                    });
                    $(extraFolderSelect).selectpicker('refresh');
                })
                .catch(error => {
                    console.error("Failed to load extra folders:", error);
                });
    }

    // åŠ è½½ Extra æ–‡ä»¶å¤¹å±‚çº§åˆ—è¡¨
    function loadExtraFolderLevels() {
        fetch('/extra-folder-levels')
            .then(response => response.json())
            .then(data => {
                const firstLevelSelect = document.getElementById('first_level');
                const secondLevelSelect = document.getElementById('second_level');
                const thirdLevelSelect = document.getElementById('third_level');

                // æ¸…ç©ºå½“å‰é€‰é¡¹
                firstLevelSelect.innerHTML = '';
                secondLevelSelect.innerHTML = '';
                thirdLevelSelect.innerHTML = '';

                // æ·»åŠ ç¬¬ä¸€å±‚çº§é€‰é¡¹
                data.first_level.forEach(folder => {
                    const option = document.createElement('option');
                    option.value = folder;
                    option.textContent = folder;
                    firstLevelSelect.appendChild(option);
                });

                // æ·»åŠ ç¬¬äºŒå±‚çº§é€‰é¡¹
                data.second_level.forEach(folder => {
                    const option = document.createElement('option');
                    option.value = folder;
                    option.textContent = folder;
                    secondLevelSelect.appendChild(option);
                });

                // æ·»åŠ ç¬¬ä¸‰å±‚çº§é€‰é¡¹
                data.third_level.forEach(folder => {
                    const option = document.createElement('option');
                    option.value = folder;
                    option.textContent = folder;
                    thirdLevelSelect.appendChild(option);
                });

                // åˆ·æ–°ä¸‹æ‹‰æ¡†
                $(firstLevelSelect).selectpicker('refresh');
                $(secondLevelSelect).selectpicker('refresh');
                $(thirdLevelSelect).selectpicker('refresh');
            })
            .catch(error => {
                console.error("Failed to load extra folder levels:", error);
            });
    }

    // å†…å­˜ä¼˜åŒ–ï¼šæ·»åŠ åƒåœ¾å›æ”¶è¾…åŠ©å‡½æ•°
    function clearMemory() {
        // å¼ºåˆ¶æµè§ˆå™¨è¿›è¡Œåƒåœ¾å›æ”¶
        if (window.gc) {
            window.gc();
        } else if (window.opera && window.opera.collect) {
            window.opera.collect();
        } else {
            try {
                // åˆ›å»ºå¤§é‡å¯¹è±¡è¿«ä½¿æµè§ˆå™¨è¿›è¡Œåƒåœ¾å›æ”¶
                const arr = new Array(1000);
                for (let i = 0; i < 1000; i++) {
                    arr[i] = new Array(10000).join('x');
                }
                arr.length = 0;
            } catch (e) {
                console.log("å†…å­˜æ¸…ç†å°è¯•");
            }
        }
    }
    
    // æ·»åŠ ä¸€ä¸ªå…¨å±€æ ‡å¿—ï¼Œæ§åˆ¶æ˜¯å¦å…è®¸ç­›é€‰
    let filterEnabled = false;

    // ä¿®æ”¹ç­›é€‰å‡½æ•°ï¼Œç¡®ä¿åªèƒ½é€šè¿‡æŒ‰é’®ç‚¹å‡»è§¦å‘
    function filterExtraFolders() {
        // å¦‚æœä¸æ˜¯é€šè¿‡æŒ‰é’®ç‚¹å‡»è§¦å‘ï¼Œåˆ™ç›´æ¥è¿”å›
        if (!filterEnabled) {
            console.log('ç­›é€‰è¢«é˜»æ­¢ï¼šä¸æ˜¯é€šè¿‡æŒ‰é’®ç‚¹å‡»è§¦å‘');
            return;
        }
        
        console.log('å¼€å§‹æ‰§è¡Œç­›é€‰...');
        
        // æ˜¾ç¤ºåŠ è½½æŒ‡ç¤ºå™¨
        const loadingIndicator = document.getElementById('loading-indicator');
        if (loadingIndicator) {
            loadingIndicator.style.display = 'flex';
        } else {
            const newLoadingIndicator = document.createElement('div');
            newLoadingIndicator.id = 'loading-indicator';
            newLoadingIndicator.innerHTML = '<div class="spinner"></div><div>åŠ è½½ä¸­...</div>';
            newLoadingIndicator.style.display = 'flex';
            document.body.appendChild(newLoadingIndicator);
        }
        
        // é‡ç½®æ ‡å¿—ï¼Œé˜²æ­¢é‡å¤è°ƒç”¨
        filterEnabled = false;

        const formData = new FormData();
        
        // è·å–é€‰ä¸­çš„å€¼
        const firstLevelSelect = $('#first_level').val() || [];
        const secondLevelSelect = $('#second_level').val() || [];
        const thirdLevelSelect = $('#third_level').val() || [];
        
        console.log('ç­›é€‰æ¡ä»¶:', firstLevelSelect, secondLevelSelect, thirdLevelSelect);
        
        // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰ä¸‰ä¸ªä¸‹æ‹‰æ¡†éƒ½æœ‰é€‰æ‹©
        if (firstLevelSelect.length === 0 || secondLevelSelect.length === 0 || thirdLevelSelect.length === 0) {
            alert('è¯·åœ¨æ‰€æœ‰ä¸‰ä¸ªä¸‹æ‹‰æ¡†ä¸­éƒ½é€‰æ‹©è‡³å°‘ä¸€ä¸ªé€‰é¡¹');
            if (loadingIndicator) {
                loadingIndicator.style.display = 'none';
            }
            return;
        }
        
        // æ·»åŠ åˆ°è¡¨å•æ•°æ®
        firstLevelSelect.forEach(value => formData.append('first_level[]', value));
        secondLevelSelect.forEach(value => formData.append('second_level[]', value));
        thirdLevelSelect.forEach(value => formData.append('third_level[]', value));
        
        // æ¸…é™¤ä¹‹å‰çš„ç­›é€‰å›¾å±‚
        Object.values(extraLayers).forEach(layer => {
            if (map.hasLayer(layer)) {
                map.removeLayer(layer);
            }
        });
        extraLayers = {};
        
        // å‘é€ç­›é€‰è¯·æ±‚
        fetch('/filter', {
            method: 'POST',
            body: formData
        })
        .then(response => {
            if (!response.ok) {
                throw new Error(`HTTP error! Status: ${response.status}`);
            }
            return response.json();
        })
        .then(data => {
            console.log('ç­›é€‰ç»“æœ:', Object.keys(data).length, 'ä¸ªå›¾å±‚');
            
            if (Object.keys(data).length === 0) {
                alert('æ²¡æœ‰æ‰¾åˆ°ç¬¦åˆæ¡ä»¶çš„å›¾å±‚');
                return;
            }
            
            // å¤„ç†ç­›é€‰ç»“æœ
            Object.entries(data).forEach(([layerName, geoJsonData]) => {
                try {
                    console.log(`å¤„ç†å›¾å±‚: ${layerName}`);
                    // è§£æGeoJSONæ•°æ®
                    const parsedData = typeof geoJsonData === 'string' ? JSON.parse(geoJsonData) : geoJsonData;
                    
                    // åˆ›å»ºå›¾å±‚å¹¶æ·»åŠ åˆ°åœ°å›¾
                const layerColor = getLayerColor(layerName);
                    const layer = L.geoJSON(parsedData, {
                        style: function() {
                            return {
                        color: layerColor,
                        weight: 2,
                                opacity: 0.8,
                                fillOpacity: 0.4
                            };
                        },
                        pointToLayer: function(feature, latlng) {
                            return L.circleMarker(latlng, {
                                radius: 5,
                                fillColor: layerColor,
                                color: "#000",
                                weight: 1,
                        opacity: 1,
                                fillOpacity: 0.8
                            });
                        },
                        onEachFeature: function(feature, layer) {
                            // ä½¿ç”¨å›¾å±‚åç§°ä½œä¸ºtooltip
                            layer.bindTooltip(layerName, {
                                permanent: false,
                                direction: 'auto',
                                className: 'layer-name-tooltip'
                            });
                        }
                    });
                    
                    // ä¿å­˜å›¾å±‚å¼•ç”¨å¹¶æ·»åŠ åˆ°åœ°å›¾
                extraLayers[layerName] = layer;
                    map.addLayer(layer);
                    console.log(`å›¾å±‚ ${layerName} å·²æ·»åŠ åˆ°åœ°å›¾`);
                } catch (e) {
                    console.error(`å¤„ç†å›¾å±‚ ${layerName} æ—¶å‡ºé”™:`, e);
                }
            });
            
            // æ›´æ–°extraLayerControl
            updateExtraLayerControl();

            // æ›´æ–°å›¾ä¾‹
            updateLegend({...currentLayers, ...planLayers, ...extraLayers});
            
            console.log('å›¾å±‚å¤„ç†å®Œæˆï¼Œå·²æ›´æ–°æ§ä»¶å’Œå›¾ä¾‹');
        })
        .catch(error => {
            console.error('ç­›é€‰è¯·æ±‚å¤±è´¥:', error);
            alert('ç­›é€‰è¯·æ±‚å¤±è´¥: ' + error.message);
        })
        .finally(() => {
            // éšè—åŠ è½½æŒ‡ç¤ºå™¨
            const indicator = document.getElementById('loading-indicator');
            if (indicator) {
                indicator.style.display = 'none';
            }
        });
    }

    // é¡µé¢åŠ è½½å®Œæˆåè®¾ç½®äº‹ä»¶ç›‘å¬å™¨
    document.addEventListener('DOMContentLoaded', function() {
        console.log('DOMåŠ è½½å®Œæˆï¼Œè®¾ç½®äº‹ä»¶ç›‘å¬å™¨');
        
        // è·å–ç­›é€‰è¡¨å•å’ŒæŒ‰é’®
        const extraFolderForm = document.getElementById('extraFolderForm');
        const filterButton = extraFolderForm.querySelector('button[type="submit"]') || 
                             extraFolderForm.querySelector('button.btn-primary');
        
        if (filterButton) {
            console.log('æ‰¾åˆ°ç­›é€‰æŒ‰é’®ï¼Œç»‘å®šç‚¹å‡»äº‹ä»¶');
            // ç§»é™¤åŸæœ‰çš„onclickå±æ€§ï¼ˆå¦‚æœæœ‰ï¼‰
            filterButton.removeAttribute('onclick');
            
            // ç»‘å®šæ–°çš„ç‚¹å‡»äº‹ä»¶
            filterButton.addEventListener('click', function(e) {
                console.log('ç­›é€‰æŒ‰é’®è¢«ç‚¹å‡»');
                e.preventDefault();
                // è®¾ç½®æ ‡å¿—ï¼Œå…è®¸æ‰§è¡Œç­›é€‰
                filterEnabled = true;
                filterExtraFolders();
            });
        } else {
            console.error('æœªæ‰¾åˆ°ç­›é€‰æŒ‰é’®');
        }
        
        // é˜»æ­¢è¡¨å•çš„é»˜è®¤æäº¤è¡Œä¸º
        if (extraFolderForm) {
            extraFolderForm.addEventListener('submit', function(e) {
                console.log('é˜»æ­¢è¡¨å•é»˜è®¤æäº¤');
                e.preventDefault();
            });
        }
        
        // åŠ è½½ä¸‹æ‹‰æ¡†é€‰é¡¹
        loadExtraFolderLevels();
        
        console.log('åˆå§‹åŒ–å®Œæˆï¼Œç­‰å¾…ç”¨æˆ·æ“ä½œ');
    });

    // é˜»æ­¢è¡¨å•çš„é»˜è®¤æäº¤è¡Œä¸º
    document.getElementById('extraFolderForm').addEventListener('submit', function(e) {
        e.preventDefault();
    });

    // ä¼˜åŒ–åˆ†æ‰¹å¤„ç†å‡½æ•°
    function processBatch(entries, startIndex, batchSize, tempLayerGroup, originalData) {
        const endIndex = Math.min(startIndex + batchSize, entries.length);
        
        // å¤„ç†å½“å‰æ‰¹æ¬¡
        for (let i = startIndex; i < endIndex; i++) {
            const [layerName, geoJsonData] = entries[i];
            addExtraLayer(layerName, geoJsonData, tempLayerGroup);
            
            // å†…å­˜ä¼˜åŒ–ï¼šå¤„ç†å®Œä¸€é¡¹å°±ä»åŸå§‹æ•°æ®ä¸­åˆ é™¤
            delete originalData[layerName];
        }
        
        // å¦‚æœè¿˜æœ‰æ›´å¤šæ•°æ®ï¼Œå®‰æ’ä¸‹ä¸€æ‰¹å¤„ç†
        if (endIndex < entries.length) {
            // å†…å­˜ä¼˜åŒ–ï¼šå»¶é•¿æ‰¹æ¬¡é—´éš”ï¼Œç»™æµè§ˆå™¨æ›´å¤šæ—¶é—´è¿›è¡Œåƒåœ¾å›æ”¶
            setTimeout(() => {
                // å°è¯•åƒåœ¾å›æ”¶
                clearMemory();
                processBatch(entries, endIndex, batchSize, tempLayerGroup, originalData);
            }, 100); // å¢åŠ å»¶è¿Ÿ
        } else {
            // æ‰€æœ‰æ‰¹æ¬¡å¤„ç†å®Œæ¯•ï¼Œä¸€æ¬¡æ€§æ·»åŠ åˆ°åœ°å›¾
            tempLayerGroup.addTo(map);
            
            // æ›´æ–°å›¾ä¾‹å’Œæ§ä»¶
            updateLegend({ ...currentLayers, ...planLayers, ...extraLayers });
            updateExtraLayerControl();
            
            // ç§»é™¤åŠ è½½æŒ‡ç¤ºå™¨
            const loadingIndicator = document.getElementById('loading-indicator');
            if (loadingIndicator) {
                document.body.removeChild(loadingIndicator);
            }
            
            // æœ€ç»ˆæ¸…ç†
            clearMemory();
        }
    }

    // ä¼˜åŒ–æ·»åŠ å›¾å±‚å‡½æ•°
    function addExtraLayer(layerName, geoJsonData, targetGroup) {
        try {
            // å†…å­˜ä¼˜åŒ–ï¼šè§£æå‰æ£€æŸ¥æ•°æ®å¤§å°
            if (geoJsonData.length > 1000000) { // å¦‚æœæ•°æ®è¶…è¿‡1MB
                console.warn(`å›¾å±‚ ${layerName} æ•°æ®è¿‡å¤§ (${Math.round(geoJsonData.length/1024)}KB)ï¼Œå¯èƒ½å¯¼è‡´æ€§èƒ½é—®é¢˜`);
            }
            
            const parsedData = JSON.parse(geoJsonData);
                const layerColor = getLayerColor(layerName);
            
            // å†…å­˜ä¼˜åŒ–ï¼šç®€åŒ–æ ·å¼è®¾ç½®
            const layer = L.geoJSON(parsedData, {
                    style: {
                        color: layerColor,
                        weight: 2,
                        opacity: 1,
                        fillOpacity: 0.2
                },
                pointToLayer: function (feature, latlng) {
                    return L.circleMarker(latlng, {
                        radius: 5,
                        fillColor: layerColor,
                        color: "#000",
                        weight: 1,
                        opacity: 1,
                        fillOpacity: 0.8
                    });
                },
                onEachFeature: function(feature, layer) {
                    // å†…å­˜ä¼˜åŒ–ï¼šåªåœ¨é¼ æ ‡æ‚¬åœæ—¶åˆ›å»ºtooltip
                    layer.on('mouseover', function() {
                        if (!layer._tooltip) {
                            layer.bindTooltip(layerName, {
                                permanent: false,
                                direction: 'auto',
                                sticky: true,
                                offset: [10, 0],
                                opacity: 0.9,
                                className: 'leaflet-tooltip-custom'
                            });
                            layer.openTooltip();
                        }
                    });
                }
            });
            
            // æ·»åŠ åˆ°ä¸´æ—¶å›¾å±‚ç»„
            layer.addTo(targetGroup);
            
            // ä¿å­˜å¼•ç”¨ä½†ä¸ç«‹å³æ·»åŠ åˆ°åœ°å›¾
            extraLayers[layerName] = layer;
            extraControl.addOverlay(layer, layerName);
            
            // å†…å­˜ä¼˜åŒ–ï¼šé‡Šæ”¾ä¸´æ—¶å˜é‡
            parsedData = null;
            geoJsonData = null;
        } catch (e) {
            console.error(`å¤„ç†å›¾å±‚ ${layerName} æ—¶å‡ºé”™:`, e);
        }
    }

    // é€‰æ‹©å…¨éƒ¨é€‰é¡¹
    function selectAll(selectId) {
        const selectElement = document.getElementById(selectId);
        Array.from(selectElement.options).forEach(option => option.selected = true);
        $(selectElement).selectpicker('refresh');
    }

    // å–æ¶ˆå…¨éƒ¨é€‰é¡¹
    function deselectAll(selectId) {
        const selectElement = document.getElementById(selectId);
        Array.from(selectElement.options).forEach(option => option.selected = false);
        $(selectElement).selectpicker('refresh');
    }

    function debounce(func, wait) {
        let timeout;
        return function(...args) {
            clearTimeout(timeout);
            timeout = setTimeout(() => func.apply(this, args), wait);
        };
    }

    // åˆ é™¤å…³é—­æ‰€æœ‰å›¾å±‚çš„å‡½æ•°
    function closeAllFilteredLayers() {
        // ç§»é™¤æ‰€æœ‰ç­›é€‰å‡ºçš„å›¾å±‚
        Object.values(extraLayers).forEach(layer => {
            if (map.hasLayer(layer)) {
                map.removeLayer(layer);
            }
        });
        
        // æ¸…ç©ºextraLayerså¯¹è±¡
        extraLayers = {};
        
        // æ›´æ–°extraLayerControl
        updateExtraLayerControl();

        // æ›´æ–°å›¾ä¾‹
        updateLegend({...currentLayers, ...planLayers, ...extraLayers});
        
        console.log('å·²å…³é—­æ‰€æœ‰ç­›é€‰å›¾å±‚');
    }


    const debouncedFilterExtraFolders = debounce(filterExtraFolders, 300);  // 300ms å»¶æ—¶

    document.getElementById('first_level').addEventListener('change', debouncedFilterExtraFolders);
    document.getElementById('second_level').addEventListener('change', debouncedFilterExtraFolders);
    document.getElementById('third_level').addEventListener('change', debouncedFilterExtraFolders);


    // å…¶ä»–å‡½æ•°ï¼ˆå¦‚ loadCurrentLayersã€loadPlanLayers ç­‰ï¼‰ä¿æŒä¸å˜
    function loadCurrentLayers() {
        fetch('/base/current-layers')
            .then(response => response.json())
            .then(data => {
                Object.entries(data.current_shapefiles).forEach(([layerName, geoJsonData]) => {
                    const layerColor = getLayerColor(layerName);
                    const layer = L.geoJSON(JSON.parse(geoJsonData), {
                        style: {
                            color: layerColor,
                            weight: 2,
                            opacity: 1,
                            fillOpacity: 0.2
                        },
                        pointToLayer: function (feature, latlng) {
                            return L.circleMarker(latlng, {
                                radius: 5,
                                fillColor: layerColor,
                                color: "#000",
                                weight: 1,
                                opacity: 1,
                                fillOpacity: 0.8
                            });
                        },
                        onEachFeature: function(feature, layer) {
                            layer.bindTooltip(layerName, {
                                permanent: false,
                                direction: 'auto',
                                sticky: true,  // ä½¿tooltipè·Ÿéšé¼ æ ‡
                                offset: [10, 0],  // æ°´å¹³åç§»10åƒç´ ï¼Œé¿å…è¢«é¼ æ ‡é®æŒ¡
                                opacity: 0.9,
                                className: 'leaflet-tooltip-custom'  // è‡ªå®šä¹‰CSSç±»
                            });
                        }
                    }).addTo(layerGroup);
                    currentLayers[layerName] = layer;
                    
                    layerControl.addOverlay(layer, layerName);
                    layer.on('add remove', function() {
                        updateLegend({ ...currentLayers, ...planLayers, ...extraLayers });
                    });
                });

                updateLegend({ ...currentLayers, ...planLayers, ...extraLayers });

                const bounds = layerGroup.getBounds();
                if (bounds.isValid()) {
                    map.fitBounds(bounds, { padding: [50, 50] });
                }
            })
            .catch(error => {
                console.error("Failed to load Current layers:", error);
            });
    }

    function loadPlanLayers() {
        fetch('/base/plan-layers')
            .then(response => response.json())
            .then(data => {
                Object.entries(data.plan_shapefiles).forEach(([layerName, geoJsonData]) => {
                    const layerColor = getLayerColor(layerName);
                    const layer = L.geoJSON(JSON.parse(geoJsonData), {
                        style: {
                            color: layerColor,
                            weight: 2,
                            opacity: 1,
                            fillOpacity: 0.2
                        },
                        pointToLayer: function (feature, latlng) {
                            return L.circleMarker(latlng, {
                                radius: 5,
                                fillColor: layerColor,
                                color: "#000",
                                weight: 1,
                                opacity: 1,
                                fillOpacity: 0.8
                            });
                        },
                        onEachFeature: function(feature, layer) {
                            layer.bindTooltip(layerName, {
                                permanent: false,
                                direction: 'auto',
                                sticky: true,  // ä½¿tooltipè·Ÿéšé¼ æ ‡
                                offset: [10, 0],  // æ°´å¹³åç§»10åƒç´ ï¼Œé¿å…è¢«é¼ æ ‡é®æŒ¡
                                opacity: 0.9,
                                className: 'leaflet-tooltip-custom'  // è‡ªå®šä¹‰CSSç±»
                            });
                        }
                    }).addTo(layerGroup);
                    planLayers[layerName] = layer;
                    
                    layerControlCopy.addOverlay(layer, layerName);
                    layer.on('add remove', function() {
                        updateLegend({ ...currentLayers, ...planLayers, ...extraLayers });
                    });
                });

                updateLegend({ ...currentLayers, ...planLayers, ...extraLayers });

                const bounds = layerGroup.getBounds();
                if (bounds.isValid()) {
                    map.fitBounds(bounds, { padding: [50, 50] });
                }
            })
            .catch(error => {
                console.error("Failed to load Plan layers:", error);
            });
    }



    function loadExtraLayers(page = 1, pageSize = 10) {
        fetch('/extra-layers', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ page, pageSize })
        })
        .then(response => response.json())
        .then(data => {
            Object.entries(data.extra_shapefiles).forEach(([layerName, geoJsonData]) => {
                const layerColor = getLayerColor(layerName);
                const layer = L.geoJSON(JSON.parse(geoJsonData), {
                    style: {
                        color: layerColor,
                        weight: 2,
                        opacity: 1,
                        fillOpacity: 0.2
                    },
                    pointToLayer: function (feature, latlng) {
                        return L.circleMarker(latlng, {
                            radius: 5,
                            fillColor: layerColor,
                            color: "#000",
                            weight: 1,
                            opacity: 1,
                            fillOpacity: 0.8
                        });
                    },
                    onEachFeature: function(feature, layer) {
                        layer.bindTooltip(layerName, {
                            permanent: false,
                            direction: 'auto',
                            sticky: true,  // ä½¿tooltipè·Ÿéšé¼ æ ‡
                            offset: [10, 0],  // æ°´å¹³åç§»10åƒç´ ï¼Œé¿å…è¢«é¼ æ ‡é®æŒ¡
                            opacity: 0.9,
                            className: 'leaflet-tooltip-custom'  // è‡ªå®šä¹‰CSSç±»
                        });
                    }
                }).addTo(layerGroup);
                extraLayers[layerName] = layer;
                layerControl.addOverlay(layer, layerName);
            });

            updateLegend({ ...currentLayers, ...planLayers, ...extraLayers });

            if (data.hasMore) {
                loadExtraLayers(page + 1, pageSize);  // åŠ è½½ä¸‹ä¸€é¡µ
            }
        })
        .catch(error => {
            console.error("Failed to load Extra layers:", error);
        });
    }


    // é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–
    document.addEventListener('DOMContentLoaded', () => {
        loadCurrentLayers();
        loadPlanLayers();
        loadExtraLayers();
        loadExtraFolderLevels(); // åŠ è½½ Extra æ–‡ä»¶å¤¹å±‚çº§åˆ—è¡¨
    });

    // ä¿®æ”¹updateExtraLayerControlå‡½æ•°ä¸­çš„å®½åº¦è®¾ç½®
    function updateExtraLayerControl() {
        // æ›´æ–°extraLayerControlçš„å†…å®¹
        const extraLayersList = document.getElementById('extraLayersList');
        if (extraLayersList) {
            extraLayersList.innerHTML = '';
            
            Object.entries(extraLayers).forEach(([name, layer]) => {
                const label = document.createElement('label');
                
                const input = document.createElement('input');
                input.type = 'checkbox';
                input.checked = map.hasLayer(layer);
                input.onchange = function() {
                    if (this.checked) {
                        map.addLayer(layer);
                    } else {
                        map.removeLayer(layer);
                    }
        updateLegend({...currentLayers, ...planLayers, ...extraLayers});
    };

                label.appendChild(input);
                label.appendChild(document.createTextNode(' ' + name));
                
                extraLayersList.appendChild(label);
            });
        }
        
        // è°ƒæ•´extraLayerControlçš„å®½åº¦
        const extraLayerControl = document.getElementById('extraLayerControl');
        if (extraLayerControl) {
            // ä½¿ç”¨å›ºå®šå®½åº¦ï¼Œä¸å†æ ¹æ®å†…å®¹åŠ¨æ€è°ƒæ•´
            extraLayerControl.style.width = '600px';
            extraLayerControl.style.minWidth = '600px';
            extraLayerControl.style.maxWidth = '600px';
        }
    }

    // åœ¨åˆå§‹åŒ–åœ°å›¾åæ·»åŠ æ–°æ§ä»¶
    extraControl.onAdd = function (map) {
        const container = L.DomUtil.create('div', 'leaflet-control-layers-copy');
        container.id = 'extraLayerControl';
        container.style.width = '600px';  // è®¾ç½®åˆå§‹å®½åº¦
        container.style.minWidth = '600px';
        container.style.maxWidth = '600px';
        
        // åˆ›å»ºæ ‡é¢˜æ ï¼ŒåŒ…å«æ ‡é¢˜å’ŒæŠ˜å æŒ‰é’®
        const headerDiv = document.createElement('div');
        headerDiv.style.display = 'flex';
        headerDiv.style.justifyContent = 'space-between';
        headerDiv.style.alignItems = 'center';
        headerDiv.style.marginBottom = '5px';
        
        // æ·»åŠ æ ‡é¢˜
        const titleDiv = document.createElement('div');
        titleDiv.innerHTML = '<strong>è®¾è®¡æ–¹æ¡ˆ</strong>';
        headerDiv.appendChild(titleDiv);
        
        // æ·»åŠ æŠ˜å æŒ‰é’®
        const collapseBtn = document.createElement('button');
        collapseBtn.innerHTML = 'âˆ’';  // ä½¿ç”¨å‡å·è¡¨ç¤ºæŠ˜å 
        collapseBtn.style.width = '24px';
        collapseBtn.style.height = '24px';
        collapseBtn.style.border = '1px solid #ccc';
        collapseBtn.style.borderRadius = '3px';
        collapseBtn.style.background = 'white';
        collapseBtn.style.cursor = 'pointer';
        collapseBtn.title = 'æŠ˜å /å±•å¼€';
        
        // è®¾ç½®æŠ˜å /å±•å¼€åŠŸèƒ½
        setupCollapseButton(collapseBtn, container, 'extra');
        
        headerDiv.appendChild(collapseBtn);
        
        // åˆ›å»ºæŒ‰é’®åŒºåŸŸå’Œå†…å®¹åŒºåŸŸ
        const buttonsDiv = document.createElement('div');
        buttonsDiv.className = 'leaflet-control-buttons';
        buttonsDiv.innerHTML = `
            <button style="float: left;">å…¨éƒ¨æ‰“å¼€</button>
            <button style="float: right;">å…¨éƒ¨å…³é—­</button>
        `;
        
        const listDiv = document.createElement('div');
        listDiv.className = 'leaflet-control-layers-overlays';
        listDiv.id = 'extraLayersList';
        
        // æ·»åŠ å„ä¸ªå…ƒç´ åˆ°å®¹å™¨
        container.appendChild(headerDiv);
        container.appendChild(buttonsDiv);
        container.appendChild(listDiv);

        // æ·»åŠ æŒ‰é’®äº‹ä»¶å¤„ç†
        buttonsDiv.querySelector('button:nth-child(1)').onclick = () => {
            Object.values(extraLayers).forEach(layer => map.addLayer(layer));
        updateLegend({...currentLayers, ...planLayers, ...extraLayers});
            updateExtraLayerControl();
    };

        buttonsDiv.querySelector('button:nth-child(2)').onclick = () => {
            Object.values(extraLayers).forEach(layer => map.removeLayer(layer));
        updateLegend({...currentLayers, ...planLayers, ...extraLayers});
            updateExtraLayerControl();
        };
        
        // åˆå§‹è®¾ç½®ä¸ºå±•å¼€çŠ¶æ€
        container.classList.add('control-expanded');
        
        return container;
    };
    extraControl.addTo(map);

    // æ·»åŠ CSSæ ·å¼ï¼Œç¡®ä¿å›¾ä¾‹é¡¹ç›®æ ·å¼ä¸€è‡´
    const styleElement = document.createElement('style');
    styleElement.textContent = `
        .leaflet-legend {
            font-family: Arial, sans-serif;
            font-size: 12px;
            line-height: 1.5;
        }
        .legend-item {
            margin: 5px 0;
            display: flex;
            align-items: center;
        }
        .legend-color {
            width: 16px;
            height: 16px;
            margin-right: 8px;
            border-radius: 2px;
        }
        /* æ»šåŠ¨æ¡æ ·å¼ */
        .leaflet-legend::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }
        .leaflet-legend::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 3px;
        }
        .leaflet-legend::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 3px;
        }
        .leaflet-legend::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
    `;
    document.head.appendChild(styleElement);

    // é˜²æ­¢åœ¨æ§ä»¶ä¸Šæ»šåŠ¨é¼ æ ‡æ»šè½®æ—¶ç¼©æ”¾åœ°å›¾
    function preventWheelPropagation(element) {
        if (!element) return;
        
        element.addEventListener('wheel', function(e) {
            // æ— æ¡ä»¶é˜»æ­¢äº‹ä»¶ä¼ æ’­åˆ°åœ°å›¾
            e.stopPropagation();
            
            // ä»…å½“æ§ä»¶ä¸å¯æ»šåŠ¨æˆ–å·²åˆ°è¾¾æ»šåŠ¨è¾¹ç•Œæ—¶é˜»æ­¢é»˜è®¤è¡Œä¸º
            const isScrollable = this.scrollHeight > this.clientHeight;
            const isScrollingDown = e.deltaY > 0;
            const isScrollingUp = e.deltaY < 0;
            const isAtTop = this.scrollTop === 0;
            const isAtBottom = this.scrollTop + this.clientHeight >= this.scrollHeight - 1;
            
            // å¦‚æœæ§ä»¶ä¸å¯æ»šåŠ¨ï¼Œæˆ–è€…å·²ç»æ»šåŠ¨åˆ°è¾¹ç•Œï¼Œé˜»æ­¢é»˜è®¤æ»šåŠ¨è¡Œä¸º
            if (!isScrollable || 
                (isScrollingUp && isAtTop) || 
                (isScrollingDown && isAtBottom)) {
                e.preventDefault();
            }
            
            // æ³¨æ„ï¼šè¿™é‡Œä¸è¿”å›ï¼Œç¡®ä¿äº‹ä»¶è¢«é˜»æ­¢ä¼ æ’­åˆ°åœ°å›¾
        }, { passive: false });
    }

    // ç­‰å¾…æ‰€æœ‰æ§ä»¶åŠ è½½å®Œæˆååº”ç”¨é˜»æ­¢æ»šè½®ä¼ æ’­
    document.addEventListener('DOMContentLoaded', function() {
        // è®¾ç½®å›¾ä¾‹æ§ä»¶
        const legendElement = document.querySelector('.leaflet-legend');
        if (legendElement) {
            preventWheelPropagation(legendElement);
        }
        
        // è®¾ç½®å·¦ä¸‹è§’çš„æ‰€æœ‰æ§ä»¶
        const controlLayers = document.querySelectorAll('.leaflet-control-layers-expanded');
        controlLayers.forEach(function(control) {
            preventWheelPropagation(control);
        });
    });

    // ç›‘å¬æ§ä»¶åˆ›å»º
    map.on('layeradd', function() {
        setTimeout(function() {
            // é‡æ–°æŸ¥æ‰¾æ‰€æœ‰æ§ä»¶å¹¶åº”ç”¨æ»šè½®é˜»æ­¢
            const legendElement = document.querySelector('.leaflet-legend');
            if (legendElement) {
                preventWheelPropagation(legendElement);
            }
            
            const controlLayers = document.querySelectorAll('.leaflet-control-layers-expanded');
            controlLayers.forEach(function(control) {
                preventWheelPropagation(control);
            });
        }, 100);
    });

    // åœ¨åˆ›å»ºlayerControlåï¼Œæ·»åŠ äº‹ä»¶ç›‘å¬
    layerControl.on('add remove', function(e) {
        // æ›´æ–°å›¾ä¾‹
        updateLegend({ ...currentLayers, ...planLayers, ...extraLayers });
    });

    // åœ¨è„šæœ¬æœ«å°¾æ·»åŠ layerControlCopyçš„äº‹ä»¶ç›‘å¬
    layerControlCopy.on('add remove', function(e) {
        // æ›´æ–°å›¾ä¾‹
        updateLegend({ ...currentLayers, ...planLayers, ...extraLayers });
    });

    // æ”¹è¿›çš„ä¿å­˜è§†å›¾å‡½æ•°ï¼ŒåŒ…å«ç­›é€‰æ¡ä»¶
    function saveViewDirectly() {
        console.log("å¼€å§‹ä¿å­˜è§†å›¾...");
        
        // æ”¶é›†å½“å‰è§†å›¾ä¿¡æ¯
        const viewData = {
            center: map.getCenter(),
            zoom: map.getZoom(),
            layers: {
                current: {},
                plan: {},
                extra: {}
            },
            // ä¿å­˜ç­›é€‰æ¡ä»¶
            filters: {
                first_level: $('#first_level').val() || [],
                second_level: $('#second_level').val() || [],
                third_level: $('#third_level').val() || []
            },
            // ä¿å­˜ç­›é€‰å‡ºçš„å›¾å±‚ä¿¡æ¯
            extraLayersInfo: {},
            timestamp: new Date().toISOString()
        };
        
        // æ”¶é›†å½“å‰å›¾å±‚çŠ¶æ€
        Object.entries(currentLayers).forEach(([name, layer]) => {
            viewData.layers.current[name] = map.hasLayer(layer);
        });
        
        Object.entries(planLayers).forEach(([name, layer]) => {
            viewData.layers.plan[name] = map.hasLayer(layer);
        });
        
        // ä¿å­˜ç­›é€‰å‡ºçš„å›¾å±‚åŠå…¶çŠ¶æ€
        Object.entries(extraLayers).forEach(([name, layer]) => {
            viewData.layers.extra[name] = map.hasLayer(layer);
            
            // ä¿å­˜å›¾å±‚çš„GeoJSONæ•°æ®
            if (layer && layer.toGeoJSON) {
                try {
                    viewData.extraLayersInfo[name] = {
                        geoJson: layer.toGeoJSON(),
                        color: getLayerColor(name)
                    };
                } catch (e) {
                    console.warn(`æ— æ³•ä¿å­˜å›¾å±‚ ${name} çš„GeoJSONæ•°æ®:`, e);
                }
            }
        });
        
        console.log("è§†å›¾æ•°æ®æ”¶é›†å®Œæˆ:", viewData);
        
        // è½¬æ¢ä¸ºJSON
        const jsonData = JSON.stringify(viewData, null, 2);
        
        // åˆ›å»ºä¸‹è½½é“¾æ¥
        const blob = new Blob([jsonData], {type: 'application/json'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `map_view_${new Date().toISOString().replace(/[:.]/g, '-')}.json`;
        
        console.log("å‡†å¤‡ä¸‹è½½æ–‡ä»¶...");
        document.body.appendChild(a);
        a.click();
        
        // æ¸…ç†
        setTimeout(() => {
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            console.log("æ–‡ä»¶ä¸‹è½½å®Œæˆï¼Œæ¸…ç†å®Œæˆ");
        }, 100);
    }

    // æ”¹è¿›çš„åŠ è½½è§†å›¾å‡½æ•°ï¼Œå¢å¼ºé”™è¯¯å¤„ç†
    function loadViewDirectly(file) {
        if (!file) {
            console.error("æ²¡æœ‰é€‰æ‹©æ–‡ä»¶");
            return;
        }
        
        console.log("å¼€å§‹åŠ è½½è§†å›¾æ–‡ä»¶:", file.name);
        
        const reader = new FileReader();
        
        reader.onload = function(e) {
            try {
                console.log("æ–‡ä»¶è¯»å–å®Œæˆï¼Œè§£æJSON...");
                let viewData;
                
                try {
                    viewData = JSON.parse(e.target.result);
                    console.log("JSONè§£ææˆåŠŸ:", viewData);
                } catch (parseError) {
                    console.error("JSONè§£æå¤±è´¥:", parseError);
                    alert('JSONè§£æå¤±è´¥: ' + parseError.message);
                    return;
                }
                
                // è®¾ç½®åœ°å›¾ä¸­å¿ƒå’Œç¼©æ”¾çº§åˆ«
                try {
                    if (viewData.center && viewData.zoom) {
                        console.log(`è®¾ç½®åœ°å›¾è§†å›¾: ä¸­å¿ƒç‚¹ [${viewData.center.lat}, ${viewData.center.lng}], ç¼©æ”¾çº§åˆ« ${viewData.zoom}`);
                        map.setView([viewData.center.lat, viewData.center.lng], viewData.zoom);
                    }
                } catch (viewError) {
                    console.error("è®¾ç½®åœ°å›¾è§†å›¾å¤±è´¥:", viewError);
                    // ç»§ç»­æ‰§è¡Œï¼Œä¸ä¸­æ–­æµç¨‹
                }
                
                // åº”ç”¨å›¾å±‚çŠ¶æ€
                try {
                    if (viewData.layers) {
                        console.log("å¼€å§‹åº”ç”¨å›¾å±‚çŠ¶æ€...");
                        
                        // å…ˆç§»é™¤æ‰€æœ‰å›¾å±‚
                        try {
                            Object.values(currentLayers).forEach(layer => {
                                if (map.hasLayer(layer)) {
                                    map.removeLayer(layer);
                                }
                            });
                            
                            Object.values(planLayers).forEach(layer => {
                                if (map.hasLayer(layer)) {
                                    map.removeLayer(layer);
                                }
                            });
                            
                            Object.values(extraLayers).forEach(layer => {
                                if (map.hasLayer(layer)) {
                                    map.removeLayer(layer);
                                }
                            });
                        } catch (removeError) {
                            console.error("ç§»é™¤å›¾å±‚å¤±è´¥:", removeError);
                            // ç»§ç»­æ‰§è¡Œï¼Œä¸ä¸­æ–­æµç¨‹
                        }
                        
                        // æ¸…ç©ºextraLayers
                        try {
                            extraLayers = {};
                            console.log("å·²æ¸…ç©ºextraLayers");
                        } catch (clearError) {
                            console.error("æ¸…ç©ºextraLayerså¤±è´¥:", clearError);
                        }
                        
                        // æ·»åŠ åº”è¯¥æ˜¾ç¤ºçš„å›¾å±‚
                        try {
                            if (viewData.layers.current) {
                                Object.entries(viewData.layers.current).forEach(([name, visible]) => {
                                    try {
                                        if (visible && currentLayers[name]) {
                                            console.log(`æ·»åŠ ç°çŠ¶å›¾å±‚: ${name}`);
                                            map.addLayer(currentLayers[name]);
                                        }
                                    } catch (e) {
                                        console.error(`æ·»åŠ ç°çŠ¶å›¾å±‚ ${name} å¤±è´¥:`, e);
                                    }
                                });
                            }
                            
                            if (viewData.layers.plan) {
                                Object.entries(viewData.layers.plan).forEach(([name, visible]) => {
                                    try {
                                        if (visible && planLayers[name]) {
                                            console.log(`æ·»åŠ è§„åˆ’å›¾å±‚: ${name}`);
                                            map.addLayer(planLayers[name]);
                                        }
                                    } catch (e) {
                                        console.error(`æ·»åŠ è§„åˆ’å›¾å±‚ ${name} å¤±è´¥:`, e);
                                    }
                                });
                            }
                        } catch (addLayerError) {
                            console.error("æ·»åŠ åŸºç¡€å›¾å±‚å¤±è´¥:", addLayerError);
                        }
                        
                        // æ¢å¤ç­›é€‰æ¡ä»¶
                        try {
                            if (viewData.filters) {
                                console.log("æ¢å¤ç­›é€‰æ¡ä»¶:", viewData.filters);
                                
                                // è®¾ç½®ä¸‹æ‹‰æ¡†é€‰ä¸­å€¼
                                if (viewData.filters.first_level && $('#first_level').length) {
                                    $('#first_level').val(viewData.filters.first_level);
                                    console.log("å·²è®¾ç½®first_level:", viewData.filters.first_level);
                                }
                                
                                if (viewData.filters.second_level && $('#second_level').length) {
                                    $('#second_level').val(viewData.filters.second_level);
                                    console.log("å·²è®¾ç½®second_level:", viewData.filters.second_level);
                                }
                                
                                if (viewData.filters.third_level && $('#third_level').length) {
                                    $('#third_level').val(viewData.filters.third_level);
                                    console.log("å·²è®¾ç½®third_level:", viewData.filters.third_level);
                                }
                            }
                        } catch (filterError) {
                            console.error("æ¢å¤ç­›é€‰æ¡ä»¶å¤±è´¥:", filterError);
                        }
                        
                        // æ¢å¤ç­›é€‰å‡ºçš„å›¾å±‚
                        try {
                            if (viewData.extraLayersInfo) {
                                console.log("æ¢å¤ç­›é€‰å‡ºçš„å›¾å±‚...");
                                
                                Object.entries(viewData.extraLayersInfo).forEach(([name, info]) => {
                                    try {
                                        if (info.geoJson) {
                                            console.log(`æ¢å¤è®¾è®¡æ–¹æ¡ˆå›¾å±‚: ${name}`);
                                            
                                            // åˆ›å»ºå›¾å±‚
                                            const layer = L.geoJSON(info.geoJson, {
                                                style: function() {
                                                    return {
                                                        color: info.color || getLayerColor(name),
                                                        weight: 2,
                                                        opacity: 0.8,
                                                        fillOpacity: 0.4
                                                    };
                                                },
                                                pointToLayer: function(feature, latlng) {
                                                    return L.circleMarker(latlng, {
                                                        radius: 5,
                                                        fillColor: info.color || getLayerColor(name),
                                                        color: "#000",
                                                        weight: 1,
                                                        opacity: 1,
                                                        fillOpacity: 0.8
                                                    });
                                                },
                                                onEachFeature: function(feature, layer) {
                                                    // ä½¿ç”¨å›¾å±‚åç§°ä½œä¸ºtooltip
                                                    layer.bindTooltip(name, {
                                                        permanent: false,
                                                        direction: 'auto',
                                                        sticky: true,
                                                        offset: [10, 0],
                                                        opacity: 0.9,
                                                        className: 'leaflet-tooltip-custom'
                                                    });
                                                }
                                            });
                                            
                                            // ä¿å­˜å¼•ç”¨
                                            extraLayers[name] = layer;
                                            
                                            // å¦‚æœè¯¥å›¾å±‚åº”è¯¥æ˜¾ç¤ºï¼Œåˆ™æ·»åŠ åˆ°åœ°å›¾
                                            if (viewData.layers.extra && viewData.layers.extra[name]) {
                                                map.addLayer(layer);
                                            }
                                        }
                                    } catch (layerError) {
                                        console.error(`æ¢å¤è®¾è®¡æ–¹æ¡ˆå›¾å±‚ ${name} å¤±è´¥:`, layerError);
                                    }
                                });
                                
                                // æ›´æ–°extraControl
                                try {
                                    updateExtraLayerControl();
                                    console.log("å·²æ›´æ–°extraControl");
                                } catch (updateError) {
                                    console.error("æ›´æ–°extraControlå¤±è´¥:", updateError);
                                }
                            }
                        } catch (extraLayerError) {
                            console.error("æ¢å¤ç­›é€‰å‡ºçš„å›¾å±‚å¤±è´¥:", extraLayerError);
                        }
                        
                        // æ›´æ–°å›¾ä¾‹
                        try {
                            console.log("æ›´æ–°å›¾ä¾‹...");
        updateLegend({...currentLayers, ...planLayers, ...extraLayers});
                            console.log("å›¾å±‚åº”ç”¨å®Œæˆ");
                        } catch (legendError) {
                            console.error("æ›´æ–°å›¾ä¾‹å¤±è´¥:", legendError);
                        }
                    }
                } catch (mainError) {
                    console.error("åº”ç”¨å›¾å±‚çŠ¶æ€å¤±è´¥:", mainError);
                    alert('åº”ç”¨å›¾å±‚çŠ¶æ€å¤±è´¥: ' + mainError.message);
                    return;
                }
                
                // æ˜¾ç¤ºåŠ è½½æˆåŠŸæ¶ˆæ¯
                alert('è§†å›¾åŠ è½½æˆåŠŸï¼');
                
            } catch (error) {
                console.error('åŠ è½½è§†å›¾æ–‡ä»¶å¤±è´¥:', error);
                alert('åŠ è½½è§†å›¾æ–‡ä»¶å¤±è´¥: ' + error.message);
            }
        };
        
        reader.onerror = function(error) {
            console.error('è¯»å–æ–‡ä»¶æ—¶å‡ºé”™:', error);
            alert('è¯»å–æ–‡ä»¶æ—¶å‡ºé”™: ' + (error.message || 'æœªçŸ¥é”™è¯¯'));
        };
        
        reader.readAsText(file);
    }

    // æ·»åŠ è§†å›¾ç®¡ç†æ§ä»¶åˆ°åœ°å›¾
    function addViewManagementControl() {
        // åˆ›å»ºè‡ªå®šä¹‰æ§ä»¶
        const ViewManagementControl = L.Control.extend({
            options: {
                position: 'topleft'  // ä¸å…¨å›¾æŒ‰é’®ç›¸åŒçš„ä½ç½®
            },
            
            onAdd: function(map) {
                const container = L.DomUtil.create('div', 'leaflet-bar leaflet-control');
                container.style.marginTop = '10px';  // åœ¨å…¨å›¾æŒ‰é’®ä¸‹æ–¹ç•™å‡ºç©ºé—´
                container.style.clear = 'both';
                container.style.backgroundColor = 'white';
                
                // ä¿å­˜æŒ‰é’®
                const saveButton = L.DomUtil.create('a', '', container);
                saveButton.href = '#';
                saveButton.title = 'ä¿å­˜å½“å‰è§†å›¾';
                saveButton.innerHTML = 'ğŸ’¾';
                saveButton.style.display = 'block';
                saveButton.style.textAlign = 'center';
                saveButton.style.lineHeight = '30px';
                saveButton.style.width = '30px';
                saveButton.style.height = '30px';
                
                // åŠ è½½æŒ‰é’®
                const loadButton = L.DomUtil.create('a', '', container);
                loadButton.href = '#';
                loadButton.title = 'åŠ è½½è§†å›¾';
                loadButton.innerHTML = 'ğŸ“‚';
                loadButton.style.display = 'block';
                loadButton.style.textAlign = 'center';
                loadButton.style.lineHeight = '30px';
                loadButton.style.width = '30px';
                loadButton.style.height = '30px';
                
                // éšè—çš„æ–‡ä»¶è¾“å…¥
                const fileInput = L.DomUtil.create('input', '', container);
                fileInput.type = 'file';
                fileInput.style.display = 'none';
                fileInput.accept = '.json';
                fileInput.id = 'viewFileInput';
                
                // æ·»åŠ äº‹ä»¶å¤„ç†
                L.DomEvent.on(saveButton, 'click', function(e) {
                    L.DomEvent.stopPropagation(e);
                    L.DomEvent.preventDefault(e);
                    saveViewDirectly();
                });
                
                L.DomEvent.on(loadButton, 'click', function(e) {
                    L.DomEvent.stopPropagation(e);
                    L.DomEvent.preventDefault(e);
                    fileInput.click();
                });
                
                L.DomEvent.on(fileInput, 'change', function(e) {
                    if (fileInput.files.length > 0) {
                        loadViewDirectly(fileInput.files[0]);
                    }
                });
                
                return container;
            }
        });
        
        // æ·»åŠ æ§ä»¶åˆ°åœ°å›¾
        return new ViewManagementControl().addTo(map);
    }

    // åœ¨åœ°å›¾åˆå§‹åŒ–åæ·»åŠ è§†å›¾ç®¡ç†æ§ä»¶
    const viewManagementControl = addViewManagementControl();

    // å¢åŠ å·¦ä¸‹è§’æ§ä»¶çš„å®½åº¦
    function updateControlWidth() {
        // æ›´æ–°currentLayerControlå®½åº¦
        if (document.getElementById('currentLayerControl')) {
            const currentLayerControl = document.getElementById('currentLayerControl');
            currentLayerControl.style.width = '300px';
            currentLayerControl.style.minWidth = '300px';
        }
        
        // æ›´æ–°planLayerControlå®½åº¦
        if (document.getElementById('planLayerControl')) {
            const planLayerControl = document.getElementById('planLayerControl');
            planLayerControl.style.width = '300px';
            planLayerControl.style.minWidth = '300px';
        }
        
        // æ›´æ–°extraLayerControlå®½åº¦
        if (document.getElementById('extraLayerControl')) {
            const extraLayerControl = document.getElementById('extraLayerControl');
            extraLayerControl.style.width = '600px';
            extraLayerControl.style.minWidth = '600px';
        }
    }

    // åœ¨åœ°å›¾åŠ è½½å®Œæˆåè°ƒç”¨
    map.on('load', function() {
        updateControlWidth();
    });

    // åˆ›å»ºtooltipå†…å®¹çš„å‡½æ•°
    function createTooltipContent(properties) {
        if (!properties) return "æ— å±æ€§ä¿¡æ¯";
        
        let content = '<div style="max-width: 300px;">';
        
        // æ·»åŠ æ ‡é¢˜ï¼ˆå¦‚æœæœ‰ï¼‰
        if (properties.name || properties.NAME || properties.title || properties.TITLE) {
            const title = properties.name || properties.NAME || properties.title || properties.TITLE;
            content += `<div style="font-weight: bold; margin-bottom: 5px;">${title}</div>`;
        }
        
        // æ·»åŠ æ‰€æœ‰å±æ€§
        content += '<table style="width: 100%; border-collapse: collapse;">';
        for (const key in properties) {
            if (properties.hasOwnProperty(key) && properties[key] !== null && properties[key] !== undefined) {
                // è·³è¿‡å·²ç»ä½œä¸ºæ ‡é¢˜æ˜¾ç¤ºçš„å±æ€§
                if (key.toLowerCase() === 'name' || key.toLowerCase() === 'title') continue;
                
                content += `<tr>
                    <td style="padding: 2px; border-bottom: 1px solid #eee; font-weight: bold;">${key}:</td>
                    <td style="padding: 2px; border-bottom: 1px solid #eee;">${properties[key]}</td>
                </tr>`;
            }
        }
        content += '</table></div>';
        
        return content;
    }

    // ä¿®æ”¹ç­›é€‰å‡½æ•°ï¼Œç¡®ä¿æ·»åŠ å›¾å±‚åç§°çš„tooltip
    function filterLayers() {
        // è·å–ç­›é€‰æ¡ä»¶
        const firstLevel = $('#first_level').val() || [];
        const secondLevel = $('#second_level').val() || [];
        const thirdLevel = $('#third_level').val() || [];
        
        console.log('ç­›é€‰æ¡ä»¶:', firstLevel, secondLevel, thirdLevel);
        
        // æ¸…é™¤ç°æœ‰çš„ç­›é€‰å›¾å±‚
        Object.values(extraLayers).forEach(layer => {
            if (map.hasLayer(layer)) {
                map.removeLayer(layer);
            }
        });
        extraLayers = {};
        
        // å¦‚æœæ²¡æœ‰é€‰æ‹©ä»»ä½•æ¡ä»¶ï¼Œåˆ™ä¸æ˜¾ç¤ºä»»ä½•å›¾å±‚
        if (firstLevel.length === 0 && secondLevel.length === 0 && thirdLevel.length === 0) {
            updateExtraLayerControl();
            updateLegend({...currentLayers, ...planLayers, ...extraLayers});
            return;
        }
        
        // ç­›é€‰ç¬¦åˆæ¡ä»¶çš„å›¾å±‚
        Object.entries(allDesignLayers).forEach(([name, layer]) => {
            // æ£€æŸ¥æ˜¯å¦ç¬¦åˆç­›é€‰æ¡ä»¶
            const layerData = layer.toGeoJSON();
            let shouldInclude = false;
            
            layerData.features.forEach(feature => {
                const props = feature.properties;
                
                // æ£€æŸ¥æ˜¯å¦ç¬¦åˆä¸€çº§ç­›é€‰æ¡ä»¶
                const matchFirstLevel = firstLevel.length === 0 || 
                    (props.first_level && firstLevel.includes(props.first_level));
                
                // æ£€æŸ¥æ˜¯å¦ç¬¦åˆäºŒçº§ç­›é€‰æ¡ä»¶
                const matchSecondLevel = secondLevel.length === 0 || 
                    (props.second_level && secondLevel.includes(props.second_level));
                
                // æ£€æŸ¥æ˜¯å¦ç¬¦åˆä¸‰çº§ç­›é€‰æ¡ä»¶
                const matchThirdLevel = thirdLevel.length === 0 || 
                    (props.third_level && thirdLevel.includes(props.third_level));
                
                // å¦‚æœåŒæ—¶ç¬¦åˆæ‰€æœ‰ç­›é€‰æ¡ä»¶ï¼Œåˆ™åŒ…å«è¯¥å›¾å±‚
                if (matchFirstLevel && matchSecondLevel && matchThirdLevel) {
                    shouldInclude = true;
                }
            });
            
            if (shouldInclude) {
                // åˆ›å»ºæ–°çš„GeoJSONå›¾å±‚
                const filteredLayer = L.geoJSON(layerData, {
                    style: function() {
                        return {
                            color: getLayerColor(name),
                            weight: 2,
                            opacity: 0.8,
                            fillOpacity: 0.4
                        };
                    },
                    onEachFeature: function(feature, layer) {
                        // æ·»åŠ å›¾å±‚åç§°ä½œä¸ºtooltip
                        layer.bindTooltip(name, {
                            permanent: false,
                            direction: 'auto',
                            className: 'layer-name-tooltip'
                        });
                    }
                });
                
                // æ·»åŠ åˆ°extraLayers
                extraLayers[name] = filteredLayer;
                
                // æ·»åŠ åˆ°åœ°å›¾
                map.addLayer(filteredLayer);
            }
        });
        
        // æ›´æ–°extraLayerControl
        updateExtraLayerControl();
        
        // æ›´æ–°å›¾ä¾‹
        updateLegend({...currentLayers, ...planLayers, ...extraLayers});
    }

    </script>
</body>
</html>


